
get_paf_window <- function(data_paf, start_pos, end_pos, by_REF = T){
  # Pull out alignments from paf that include are are within the desired
  #   interval
  # INPUTS
  # data_paf [data.table]	the alignment paf
  # start_pos [int]		start postion of the window
  # end_pos [int]		end position of the window
  # by_REF [logical]		use REF (T) or QUER (F) sample for
  #				  selecting the windows
  # OUTPUT
  # data.table in same format as data_paf, including alignments that 
  #   include the interval of start_pos:end_pos, but also including columns
  #   indicating window start and end positions
  ##############################################
  if(by_REF == F){
    start_vals <- data_paf$V3
    end_vals <- data_paf$V4
  } else{
    start_vals <- data_paf$V8
    end_vals <- data_paf$V9
  }
  below_start_inds <- which(start_vals <= start_pos)
  start_below_end_inds <- which(start_vals <= end_pos)
  above_start_inds <- which(start_vals > start_pos)
  #
  below_end_inds <- which(end_vals <= end_pos)
  end_above_start_inds <- which(end_vals > start_pos)
  above_end_inds <- which(end_vals > end_pos)
  ###
  # select alignments in window
  ## within window
  in_wind_inds <- intersect(above_start_inds, below_end_inds)
  ## encompasing the window
  encomp_wind_inds <- intersect(below_start_inds, above_end_inds)
  ## overlaps start or end of window
  over_start_inds <- intersect(below_start_inds, end_above_start_inds)
  over_end_inds <- intersect(start_below_end_inds, above_end_inds)
  wind_inds <- c(in_wind_inds, encomp_wind_inds, over_start_inds, over_end_inds)
  sub_paf <- data_paf[wind_inds,]
  sub_paf <- sub_paf[order(V8),]
  sub_paf[, `:=`(WINDOW_START = start_pos,
                 WINDOW_END = end_pos)]
  return(sub_paf)
}

fill_empty_windows <- function(sub_paf_list, start_vals, len_window){
  #########
  # Fill in empty windows from get_paf_window() where there are no alignment
  #    entries within the window
  # INPUTS
  # sub_paf_list [list of data.tables]	list of paf data.tables, usually 
  #						generated by get_paf_window()
  # start_vals [vec of integerss]	vector of the starting position for
  #						each window in sub_paf_list
  # len_window [int]			The length of each window
  # OUTPUT
  # fill_paf_list = list of paf data.tables with empty tables filled in
  ###############
  fill_paf_list <- sub_paf_list
  empty_windows <- which(unlist(lapply(sub_paf_list, nrow)) == 0)
  template_tab_ind <- setdiff(seq(length(start_vals)), empty_windows)[1]
  template_tab <- sub_paf_list[[template_tab_ind]][1,]
  for(empty_ind in empty_windows){
    tmp_tab <- template_tab
    tmp_start <- start_vals[empty_ind]
    tmp_end <- tmp_start + len_window - 1
    tmp_tab[, `:=`(V3 = tmp_start,
                   V4 = tmp_end,
                   V8 = tmp_start,
                   V9 = tmp_end,
                   V10 = 0,
                   V11 = 0,
                   V12 = 0,
                   WINDOW_START = tmp_start,
                   WINDOW_END = tmp_end)]
    fill_paf_list[[empty_ind]] <- tmp_tab
  }
  return(fill_paf_list)
}

# run an if statement for nrow > 1 before running this
filter_paf_window <- function(sub_paf){
  ################
  # Find and remove overlapping alignments. Longest alignment is retained
  # INPUTS
  # sub_paf [data.table]	alignment paf, usually from get_paf_window()
  # OUTPUTS
  # filt_sub_paf = data.table in same format as sub_paf, with no
  #  overlapping alignments
  ##############
  start1 <- sub_paf$V8[c(2:nrow(sub_paf))]
  end1 <- sub_paf$V9[c(1:(nrow(sub_paf)-1))]
  # look for places with next alignment starts within the previous alignment
  start_overlap_inds <- which(start1 < end1)
  keep_inds <- c()
  out_inds <- c()
  if(length(start_overlap_inds) > 0){
    for(soi in start_overlap_inds){
      tot_inds_1 <- which(sub_paf$V8 < sub_paf[soi,V9])
      test_inds <- c(soi, tot_inds_1[tot_inds_1 > soi])
      winner <- test_inds[which.max(sub_paf[test_inds, V11])]
      loser <- setdiff(test_inds, winner)
      keep_inds <- c(keep_inds, winner)
      out_inds <- c(out_inds, loser)
    }
    out_inds <- unique(out_inds)
    filt_sub_paf <- sub_paf[-out_inds, ]
  } else{
    filt_sub_paf <- sub_paf
  }
  return(filt_sub_paf)
}

trim_window <- function(filt_sub_paf, start_pos, end_pos, by_REF = T){
  ###########
  # Adjust any windows that start or end with values that do not match
  #   the window interval perfectly
  ########### 
  if(by_REF == F){
    start_vec <- filt_sub_paf$V3
    end_vec <- filt_sub_paf$V4
  } else{
    start_vec <- filt_sub_paf$V8
    end_vec <- filt_sub_paf$V9
  }
  trim_paf <- filt_sub_paf
  start_low <- which(start_vec < start_pos)
  end_high <- which(end_vec > end_pos)
  if(length(c(start_low, end_high)) > 0){
    # percent identity of input alignments
    per_id_vec <- filt_sub_paf$V10 / filt_sub_paf$V11
    # figure out relationship of nlen with length of alignment
    raw_len <- end_vec - start_vec + 1
    per_nlen_vec <- raw_len / filt_sub_paf$V11
    #
    new_start <- start_vec
    new_start[start_low] <- start_pos
    new_end <- end_vec
    new_end[end_high] <- end_pos
    new_nlen <- round((new_end - new_start + 1) / per_nlen_vec)
    new_nmatch <- round(new_nlen * per_id_vec)
    if(by_REF == F){
      trim_paf[, `:=` (V3 = new_start,
                       V4 = new_end)]
    } else{
      trim_paf[, `:=` (V8 = new_start,
                       V9 = new_end)]
    }
    trim_paf[, `:=` (V10 = new_nmatch,
                     V11 = new_nlen)]
  }
  return(trim_paf)
}

window_quality_filt <- function(sub_paf, per_id_cut = 0.9, alen_cut = 10000, 
  map_qual_cut = 0){
  #########
  # Filter paf data.table by percent identity, length of alignnment, and
  #   mapping quality score
  # INPUTS
  # sub_paf [data.table]		paf data.table
  # per_id_cut [float]			percent identity below which will remove
  #						alignments
  # alen_cut [int]			length of alignment (from alen) below
  #						which will remove alignments
  # map_qual_cut [int]			mapping quality score below which
  #						will remove alignments
  # OUTPUT
  # qual_paf = paf data.table with lower-quality alignments removed
  #################
  per_id_vec <- sub_paf[, V10] / sub_paf[, V11]
  good_id_vec <- which(per_id_vec >= per_id_cut)
  good_len_vec <- which(sub_paf$V11 >= alen_cut)
  good_qual_vec <- which(sub_paf$V12 >= map_qual_cut)
  tot_good_inds <- sort(intersect(intersect(good_id_vec, good_len_vec), 
    good_qual_vec))
  qual_paf <- sub_paf[tot_good_inds, ]
  return(qual_paf) 
}

make_empty_paf <- function(quer_chr, quer_length, ref_chr, ref_length,
  quer_start = NA, quer_end = NA, strand = NA, ref_start = NA, ref_end = NA,
  nmatch = 0, n_align = 0, map_qual = NA){
  #########
  # Make an empty paf if need it for paf window analysis
  #
  # INPUTS
  # quer_chr [string]			The name of the query chromosome
  # quer_length	[int]			The length of the query chromosome
  # ref_chr [string]			The name of the reference chromosome
  # ref_length [int]			The length of the reference chromosome
  # other_options			Other parts of paf can be asigned but
  #						for now are defaulted
  # OUTPUT
  # empty_paf = data.table with single line containing info about the query
  #               and ref chromosomes
  #################
  empty_paf <- data.table(V1 = quer_chr,
                          V2 = quer_length,
                          V3 = quer_start, 
                          V4 = quer_end, 
                          V5 = strand,
                          V6 = ref_chr,
                          V7 = ref_length,
                          V8 = ref_start, 
                          V9 = ref_end,
                          V10 = nmatch, 
                          V11 = n_align,
                          V12 = map_qual)
  return(empty_paf)
}

comb_window_pafs <- function(paf_list, start_vals, len_window){
  ########
  # Combine window-based pafs into single paf with one entry per window
  #   The output contains the amount of aligned and matching sequence per
  #     window, but the sequence is not necessarily contiguous withing the
  #     window
  # INPUTS
  # paf_list [list of data.tables]	list of paf data.tables, one table for
  # 						each window
  # start_vals [vector of integers]	The start value of each window
  # len_window [int]			The length of the windows
  # OUTPUT
  # comb_window_paf = data.table in paf format with one line for each window,
  #   each line includes the total amount of aligned and matching sequence
  #   in the window
  ##############
  window_alen_vec <- unlist(lapply(paf_list, function(x) sum(x$V11)))
  window_nmatch_vec <- unlist(lapply(paf_list, function(x) sum(x$V10)))
  quer_chr <- names(which.max(table(rbindlist(paf_list)$V1)))
  ref_chr <- names(which.max(table(rbindlist(paf_list)$V6)))
  quer_length <- as.integer(names(which.max(table(rbindlist(paf_list)$V2))))
  ref_length <- as.integer(names(which.max(table(rbindlist(paf_list)$V7))))
  comb_window_paf <- data.table(V1 = quer_chr,
                                V2 = quer_length,
                                V3 = start_vals,
                                V4 = start_vals + len_window - 1,
                                V5 = '+',
                                V6 = ref_chr,
                                V7 = ref_length,
                                V8 = start_vals,
                                V9 = start_vals + len_window -1,
                                V10 = window_nmatch_vec,
                                V11 = window_alen_vec,
                                V12 = 60)
  return(comb_window_paf)
}


